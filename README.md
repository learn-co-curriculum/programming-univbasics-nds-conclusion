# Nested Data Structures Conclusion

Congratulations! This is probably the most challenging module you've seen. As
we've mentioned before, it's also the most like real-life programming.

Ultimately, programmers are called on chiefly to do one task: build systems
that take in input, process it, and return _insights_. In the late 1800's, that
took the form of punched cards and primitive tabulating machines. In the 1960's
through 1980's that took the form of punched cards and large mainframe
computers. In the 1980's through the 1990's that took the form of data off of
hard drives on personal computers. In the present day we're receiving large
data payloads on phones in our pockets are purses and the programs inside those
phones...they're processing structured data to produce _insights_. _Insights
like_:

* "How many of my followers are online right now?"
* "How many emails need to retrieved from the server?"
* "What is my phone's current latitude and longitude?"

In all of these cases the code is operating on a collection of structured data.

In this module we started by teaching you to read **four** of the most
essential nested data structures:

* `Array` of `Arrays`
* `Array` of `Hash`es
* `Hash` of `Arrays`
* `Hash` of `Hash`es

You learned to work with them and then saw that they could be mixed together to
create data structures that model the real world.

We then practiced programming with a _process_. Realizing that nested data
structures can be intimidating, we learned a process to familiarize ourselves
with complex data, learn about complex data, and then process complex data into
_insights_.

When you get stuck doing any work that involves processing data in an NDS,
refer to these labs and this process to get un-stuck:

1. Understand the NDS
  * "Pretty-Print" NDS with `pp`
  * Home-Grown Pretty-Print NDS
2. Use `[]` to verify your understanding from Step 1
  * Print values to verify your understanding
  * Leave code comments and documentation for yourself
3. Wrap uses of `[]` from Step 2 into new methods
  * Create simple methods with meaningful names ("First-Order Methods")
  * Ensure "First-Order Methods" use arguments to create flexibility
4. See-saw between bottom-up and top-down method writing
  * Write a method that provides an insight e.g. `oldest_student`
  * Evaluate your First Order Methods
  * Can you use your First-Order Methods to build the insight method's
    implementation?
    * **YES**: Great! Your method is done!
    * **NO**: Build a new method that combines _other_ methods to get closer to what the insight method needs. Repeat step 4
5. Insight method provides an insight! We're done!

Our final labs were challenging, but, we hope you can see, are very typical for
any business that's using computers and automation to run their business
better! From our little "Green Grocer" all the way to the largest corporations
or scientific data sets, processing NDS into _insights_ is possibly the
briefest and most universal expression of why programmers are hired.

These _insights_ are the ones that can help us stop epidemics, discover new
business processes, or make each other laugh, love, and live better lives.

